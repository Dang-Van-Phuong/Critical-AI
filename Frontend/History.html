<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Critical AI | History</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">

<style>
* {
  box-sizing: border-box;
  font-family: Inter, sans-serif;
}

/* ================= ROOT COLOR SYSTEM ================= */
:root {
  --bg-dark-1: #2B1E4A;
  --bg-dark-2: #24163F;

  --primary-gradient: linear-gradient(135deg, #C52C5A, #4A5BFF);

  --glass-bg: rgba(255,255,255,0.14);
  --glass-border: rgba(123,140,255,0.5);

  --glow-blue: rgba(74,91,255,0.35);
  --glow-pink: rgba(197,44,90,0.25);

  --text-dark: #ffffff;
  --text-soft: #cfd1e6;

  --bg-light-1: #EEF0FF;
  --bg-light-2: #F7F8FF;

  --card-light: #ffffff;
  --border-light: rgba(74,91,255,0.35);

  --text-light-main: #1E1E2F;
  --text-light-soft: #475569;
}

/* ================= BODY ================= */
body {
  margin: 0;
  background: radial-gradient(circle at top, var(--bg-dark-1), var(--bg-dark-2) 60%);
  color: var(--text-dark);
}

/* ================= TOPBAR ================= */
.topbar {
  position: fixed;
  top: 0;
  width: 100%;
  padding: 16px 64px;
  background: var(--primary-gradient);
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 1000;
}

.logo-top {
  font-weight: 900;
  font-size: 21px;
  color: white;
}

.topbar nav a {
  margin-left: 28px;
  text-decoration: none;
  font-weight: 600;
  font-size: 14px;
  color: white;
  opacity: 0.8;
}

.topbar nav a:hover {
  opacity: 1;
}

/* ================= LAYOUT ================= */
.container {
  display: grid;
  grid-template-columns: 320px 1fr;

  padding-top: 140px;
  padding-left: 120px;
  padding-right: 120px;

  min-height: 100vh;   /* üî• ƒë·ªïi t·ª´ height th√†nh min-height */
  box-sizing: border-box;
}

/* ================= GLASS CARD SYSTEM ================= */
.glass {
  background: rgba(255,255,255,0.05);   /* gi·∫£m s√°ng th√™m */
  border-radius: 24px;
  padding: 28px;
  border: 1px solid rgba(123,140,255,0.25); /* vi·ªÅn m·ªù h∆°n */
  backdrop-filter: blur(12px);

  box-shadow:
    0 0 12px rgba(74,91,255,0.12),
    0 0 24px rgba(197,44,90,0.08);
}

/* ================= LEFT LIST ================= */
.history-list {
  margin-right: 40px;
  display: flex;
  flex-direction: column;

height: 264vh;
}

#historyList {
  flex: 1;
  overflow-y: auto;
  padding-right: 6px;
}

body {
  overflow-y: auto;
}

.history-title {
  font-weight: 600;

  display: -webkit-box;
  -webkit-line-clamp: 2;     /* üî• gi·ªõi h·∫°n 2 d√≤ng */
  line-clamp: 2;
  -webkit-box-orient: vertical;

  overflow: hidden;
  text-overflow: ellipsis;
}
/* ===== SCROLL DARK MODE ===== */
#historyList::-webkit-scrollbar {
  width: 6px;
}

#historyList::-webkit-scrollbar-track {
  background: transparent;
}

#historyList::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.15);
  border-radius: 10px;
}

#historyList::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.25);
}
.history-list h3 {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 24px;
}

.history-item {
  padding: 16px 18px;
  border-radius: 16px;
  margin-bottom: 16px;
  cursor: pointer;
  transition: 0.25s ease;
  font-size: 14.5px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);

  word-break: break-word;
  white-space: normal;
  line-height: 1.5;
    min-height: 90px;

  display: flex;
  flex-direction: column;
}
.history-title {
  font-weight: 600;

  display: -webkit-box;
  -webkit-line-clamp: 2;     /* ch·ªâ gi·ªõi h·∫°n title */
  line-clamp: 2;
  -webkit-box-orient: vertical;

  overflow: hidden;
  text-overflow: ellipsis;
}
.history-item small {
  opacity: 0.6;
  font-size: 12px;
}

.history-item:hover {
  transform: translateY(-4px);
  border-color: #4A5BFF;
  background: rgba(74,91,255,0.15);
}

.history-item.active {
  border: 2px solid #4A5BFF;
  background: rgba(74,91,255,0.25);
  box-shadow: 0 0 20px var(--glow-blue);
}

/* ================= MAIN TITLE ================= */
.main h1 {
  font-size: 56px;
  font-weight: 900;
  margin-bottom: 0;
  text-shadow:
    0 0 8px rgba(123,140,255,0.5),
    0 0 18px rgba(123,140,255,0.25);
}

body.light-mode .main h1 {
  background: linear-gradient(135deg, #FF2E88, #5B3CFF);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: none;
}


/* ================= CHAT ================= */
.chat-box {
  height: 50vh;
  overflow-y: auto;
  margin-bottom: 36px;
}

.msg {
  margin-bottom: 18px;
  padding: 16px 18px;
  border-radius: 18px;
  max-width: 70%;
  font-size: 15px;
  line-height: 1.6;
}

.ai {
  background: rgba(74,91,255,0.25);
}

.user {
  background: rgba(255,255,255,0.1);
  margin-left: auto;
  text-align: right;
}

/* ================= SCORE ================= */
#scorePanel {
  width: 100%;
}

.score-box {
  font-size: 15px;
  font-weight: 600;
}

.score-value {
  font-size: 36px;
  font-weight: 900;
  margin-top: 12px;
  background: linear-gradient(135deg, #FF2E88, #5B3CFF);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.score-desc {
  font-size: 12.5px;
  opacity: 0.7;
  margin-top: 10px;
  line-height: 1.5;
}

/* ===== MINDMAP TREE STYLE ===== */
.mindmap-container {
  position: relative;
  width: 100%;
  height: 700px;
  margin-top: 20px;
  overflow: hidden;
  border-radius: 20px;
  cursor: grab;
}

.export-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  padding: 10px 18px;
  border-radius: 12px;
  border: none;
  font-weight: 700;
  cursor: pointer;
  z-index: 10;

  background: linear-gradient(135deg,#C52C5A,#4A5BFF);
  color: white;

  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
  transition: 0.25s ease;
}

.export-btn:hover {
  transform: translateY(-2px);
}

.mindmap-viewport {
  position: absolute;
  width: 2000px;
  height: 1400px;
  transform-origin: 0 0;   /* üî• QUAN TR·ªåNG */
}
.mindmap-svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
    z-index: 1;
}


.mindmap-node {
  position: absolute;
  z-index: 2;   /* ƒë·∫£m b·∫£o node n·∫±m tr√™n line */
}

.mindmap-node {
  position: absolute;
  padding: 14px 22px;
  line-height: 1.6;
  margin: 10px;
  border-radius: 14px;
  font-weight: 600;
  font-size: 14px;

  white-space: normal;
  word-break: break-word;

  min-width: 140px;
  max-width: none;        /* üî• b·ªè gi·ªõi h·∫°n */
  max-width: 320px;       /* n·∫øu mu·ªën r·ªông v·ª´a ph·∫£i */
  
  color: white;
}



.level-0 { background: linear-gradient(135deg, #C52C5A, #4A5BFF); font-weight: 800; }
.level-1 { background: #8B7CFF; }
.level-2 { background: #7ED6DF; }
.level-3 { background: #F8A5C2; }
.level-4 { background: #F5CD79; }
.level-5 { background: #55E6C1; }

/* ===== SECTION CARD ===== */
.section-card {
  background: rgba(255,255,255,0.05);
  border-radius: 24px;
  padding: 28px;
  border: 1px solid rgba(123,140,255,0.25);
  margin-bottom: 0px;
}

.section-title {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 18px;
}

.score-summary-box {
  width: 100%;
}

.score-total {
  font-size: 28px;
  font-weight: 800;
  margin-bottom: 16px;
}

.summary-feedback {
  font-size: 14px;
  opacity: 0.85;
  line-height: 1.6;
}

.score-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 28px;
  width: 100%;
}

.score-help {
  font-size: 12.5px;
  opacity: 0.7;
  margin-top: 6px;
  margin-bottom: 24px;   /* üî• th√™m kho·∫£ng c√°ch xu·ªëng d∆∞·ªõi */
  cursor: pointer;
  transition: 0.2s ease;
}
.score-help:hover {
  opacity: 1;
  text-decoration: underline;
}

.score-box {
  padding: 24px;
  border-radius: 22px;
  text-align: left;
  font-size: 14px;
  font-weight: 600;
  transition: 0.25s ease;
}

.score-box:hover {
  transform: translateY(-4px);
  box-shadow: 0 0 20px var(--glow-blue);
}

.score-value {
  font-size: 40px;
  font-weight: 900;
  margin-top: 12px;
  background: linear-gradient(135deg, #FF2E88, #5B3CFF);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.score-desc {
  font-size: 12px;
  opacity: 0.6;
  margin-top: 6px;
}

.score-total {
  font-size: 32px;
  font-weight: 900;
}

.main {
  display: flex;
  flex-direction: column;
  gap: 28px;
}

.summary-card {
  display: flex;
  flex-direction: column;
  gap: 18px;
  padding: 24px;
  align-items: flex-start;   /* üî• th√™m d√≤ng n√†y */
}

.btn-wrapper {
  display: flex;
  align-items: flex-start;
}

.btn-wrapper button {
  width: auto;
}
.btn-wrapper button {
  padding: 12px 28px;
  border: none;
  border-radius: 12px;
  font-weight: 700;
  cursor: pointer;
  background: linear-gradient(135deg,#C52C5A,#4A5BFF);
  color: white;

  display: flex;              /* üî• th√™m */
  align-items: center;        /* üî• cƒÉn gi·ªØa d·ªçc */
  justify-content: center;    /* üî• cƒÉn gi·ªØa ngang */
}
.summary-card {
  display: flex;
  flex-direction: column;
  gap: 18px; 
  padding: 24px;/* üëà kho·∫£ng c√°ch gi·ªØa c√°c m·ª•c */
}

.summary-block {
  display: flex;
  flex-direction: column;
  gap: 6px; /* üëà kho·∫£ng c√°ch label v√† n·ªôi dung */
}

.label {
  font-weight: 700;
  font-size: 15px;
}

.status.done {
  color: #55E6C1;
  font-weight: 700;
}

.status.doing {
  color: #F8A5C2;
  font-weight: 700;
}

.issue-text {
  white-space: pre-line;
  line-height: 1.7;
}

/* ===== FORCE BLACK LINE WHEN EXPORT ===== */
.exporting .mindmap-line {
  stroke: #000 !important;
}

/* ===== HISTORY LIST - LIGHT MODE FIX ===== */

body.light-mode .history-list {
 background: white;
  border: 1px solid var(--border-light);
  box-shadow:
    0 10px 30px rgba(74,91,255,0.08);
}

body.light-mode .history-list h3 {
  color: var(--text-light-main);
}

body.light-mode .history-item {
  background: #F8FAFF;
  border: 1px solid rgba(74,91,255,0.15);
  color: var(--text-light-main);
}

body.light-mode .history-item small {
  color: var(--text-light-soft);
  opacity: 1;
}

body.light-mode .history-item:hover {
  background: linear-gradient(135deg, #EEF2FF, #F5F7FF);
  border-color: #4A5BFF;
  transform: translateY(-3px);
  box-shadow: 0 8px 20px rgba(74,91,255,0.15);
}

body.light-mode .history-item.active {
  background: linear-gradient(135deg, #E0E7FF, #EEF2FF);
  border: 2px solid #4A5BFF;
  box-shadow: 0 10px 25px rgba(74,91,255,0.2);
}

.exporting .mindmap-line {
  stroke: #000 !important;
}
</style>
</head>

<body>

<!-- ===== TOPBAR ===== -->
<div class="topbar">
  <div class="logo-top">Critical AI</div>
  <nav>
    <a href="Introduction.html">Gi·ªõi thi·ªáu</a>
    <a href="DefineIssue.html">Luy·ªán T·∫≠p</a>
    <a href="History.html">L·ªãch s·ª≠</a>
    <a href="Login.html">ƒêƒÉng nh·∫≠p</a>
  </nav>
</div>

<!-- ===== PAGE CONTENT ===== -->
<div class="container">

  <!-- LEFT -->
  <div class="history-list glass">
    <h3>L·ªãch s·ª≠ luy·ªán t·∫≠p</h3>

    <div id="historyList"></div>
  </div>

  <!-- RIGHT -->
  <div class="main">
    <h1 id="mainTitle">L·ªãch s·ª≠ & ƒê√°nh gi√°</h1>

    <div id="summaryCard" class="summary-card glass"></div>

<div class="section-card">
  <div class="section-title">S∆° ƒë·ªì t∆∞ duy t·ªïng h·ª£p</div>

  <div id="finalMindmap" class="mindmap-container">
    <button class="export-btn" onclick="exportMindmapImage(event)">
      ‚¨á Xu·∫•t PNG
    </button>
  </div>
</div>

    <div id="scorePanel" class="score-panel glass">

</div>
</div>
<style>
body.light-mode {
  background: radial-gradient(circle at top, var(--bg-light-1), var(--bg-light-2) 70%);
  color: var(--text-light-main);
}

body.light-mode .glass {
  background: var(--card-light);
  border: 1px solid var(--border-light);
  box-shadow:
    0 0 20px rgba(74,91,255,0.25),
    0 0 40px rgba(197,44,90,0.15),
    inset 0 0 10px rgba(74,91,255,0.05);
}

body.light-mode .summary-card {
  color: var(--text-light-soft);
}

body.light-mode .user {
  background: rgba(0,0,0,0.05);
}

body.light-mode .ai {
  background: rgba(74,91,255,0.15);
}

body.light-mode .section-card {
  background: var(--card-light);     /* tr·∫Øng gi·ªëng glass */
  border: 1px solid var(--border-light);
  box-shadow:
    0 0 20px rgba(74,91,255,0.15),
    0 0 40px rgba(197,44,90,0.08);
}
/* ================= THEME BUTTON ================= */
.theme-toggle-btn {
  position: fixed;
  bottom: 25px;
  right: 25px;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: none;
  background: var(--primary-gradient);
  color: white;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 8px 20px rgba(0,0,0,0.2);
  transition: 0.3s ease;
  z-index: 9999;
}

.theme-toggle-btn:hover {
  transform: scale(1.1);
}
</style>

<button class="theme-toggle-btn" onclick="toggleTheme()">üåô</button>

<script>
function toggleTheme() {
  document.body.classList.toggle("light-mode");
  const btn = document.querySelector(".theme-toggle-btn");

  if (document.body.classList.contains("light-mode")) {
    localStorage.setItem("theme", "light");
    btn.textContent = "‚òÄ";
  } else {
    localStorage.setItem("theme", "dark");
    btn.textContent = "üåô";
  }
}

window.onload = function() {
  const savedTheme = localStorage.getItem("theme");
  const btn = document.querySelector(".theme-toggle-btn");

  if (savedTheme === "light") {
    document.body.classList.add("light-mode");
    btn.textContent = "‚òÄ";
  }
};
</script>
<script>

async function loadHistory() {
  try {
    const token = localStorage.getItem("token");

const res = await fetch("/api/history", {
  headers: {
    "Authorization": "Bearer " + token
  }
});
    const debates = await res.json();

    const listEl = document.getElementById("historyList");
    listEl.innerHTML = "";

 debates.forEach((debate, index) => {

  const item = document.createElement("div");
  item.className = "history-item glass";

item.innerHTML = `
  <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:10px;">
<div style="flex:1; min-width:0;">
  <div class="history-title">
    ${debate.title || "Kh√¥ng c√≥ ti√™u ƒë·ªÅ"}
  </div>
  <small>
    ${new Date(debate.createdAt).toLocaleString()}
  </small>
</div>
    <button 
      onclick="deleteDebate(event,'${debate._id}')"
      style="
        background:none;
        border:none;
        color:#F87171;
        font-size:15px;
        cursor:pointer;
        flex-shrink:0;
      "
    >
      üóë
    </button>
  </div>
`;

  item.onclick = () => showDebate(debate, item);

  if (index === 0) {
    item.classList.add("active");
    showDebate(debate, item);
  }

  listEl.appendChild(item);
});

  } catch (err) {
    console.error("Load history failed", err);
  }
}

function showDebate(debate, element) {

document.getElementById("mainTitle").innerText =
  debate.title || "L·ªãch s·ª≠ & ƒê√°nh gi√°";

  document.querySelectorAll(".history-item")
    .forEach(el => el.classList.remove("active"));
  element.classList.add("active");

  const isCompleted = !!debate.scores;

  const decisionText =
    typeof debate.decision === "object"
      ? debate.decision?.updatedViewpoint || ""
      : debate.decision || "";

document.getElementById("summaryCard").innerHTML = `
  <div class="summary-block">
    <div class="label">V·∫•n ƒë·ªÅ:</div>
    <div class="issue-text">${debate.issue || ""}</div>
  </div>

  <div class="summary-block">
    <div class="label">Tr·∫°ng th√°i:</div>
    <div>
      ${
        isCompleted
          ? '<span class="status done">ƒê√£ ho√†n th√†nh</span>'
          : '<span class="status doing">Ch∆∞a ho√†n th√†nh</span>'
      }
    </div>
  </div>

  ${
    decisionText
      ? `
      <div class="summary-block">
        <div class="label">Quy·∫øt ƒë·ªãnh cu·ªëi:</div>
        <div>${decisionText}</div>
      </div>
      `
      : ""
  }

  <div class="btn-wrapper">
    <button onclick="resumeDebate('${debate._id}')">
      ${isCompleted ? "Xem l·∫°i" : "Ti·∫øp t·ª•c tranh lu·∫≠n"}
    </button>
  </div>
`;

generateFinalMindmap(
  { finalDecision: debate.title },
  debate.mindmaps || {},
  debate.roles || {}
);

  renderScores(debate);
}



function resumeDebate(debateId) {

  localStorage.setItem("currentDebateId", debateId);

const token = localStorage.getItem("token");

fetch("/debate-status", {
  method: "POST",
  headers: { 
    "Content-Type": "application/json",
    "Authorization": "Bearer " + token
  },
  body: JSON.stringify({ debateId })
})

  .then(res => res.json())
  .then(status => {

    if (!status.hasRoles) {
      window.location.href = "Overview.html";
      return;
    }

    if (!status.allCompleted) {
      window.location.href = "Roles.html";
      return;
    }

    if (!status.hasDecision) {
      window.location.href = "Decision.html";
      return;
    }

    if (!status.hasScores) {
      window.location.href = "Simulation.html";
      return;
    }

    window.location.href = "Result.html";
  })
  .catch(() => {
    window.location.href = "Overview.html";
  });
}

async function deleteDebate(event, debateId) {

  event.stopPropagation();

  const confirmDelete = confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a cu·ªôc tranh lu·∫≠n n√†y?");
  if (!confirmDelete) return;

  const token = localStorage.getItem("token");

  try {
    await fetch(`/api/history/${debateId}`, {
      method: "DELETE",
      headers: {
        "Authorization": "Bearer " + token
      }
    });

    loadHistory(); // reload l·∫°i danh s√°ch

  } catch (err) {
    alert("Kh√¥ng th·ªÉ x√≥a.");
    console.error(err);
  }
}
function renderScores(debate){

  const scorePanel = document.getElementById("scorePanel");
  scorePanel.innerHTML = "";

  if (!debate.scores) return;

  const score = debate.scores?.score || {};

  const {
    clarity = 0,
    accuracy = 0,
    precision = 0,
    relevance = 0,
    depth = 0,
    breadth = 0,
    logic = 0,
    significance = 0,
    fairness = 0
  } = score;

const total = debate.scores?.totalScore || 0;

  scorePanel.innerHTML = `
    <div class="score-summary-box">

<div class="score-total">
  T·ªïng ƒëi·ªÉm: ${total} / 90
</div>

<div class="score-help" onclick="goToCriteria()">
  N·∫øu b·∫°n c√≥ th·∫Øc m·∫Øc v·ªÅ ti√™u ch√≠ ch·∫•m ƒëi·ªÉm, 
  h√£y tham kh·∫£o th√™m ·ªü ph·∫ßn T√¨m hi·ªÉu th√™m trong trang Gi·ªõi thi·ªáu nh√©.
</div>

      <div class="score-grid">

${createScoreBox("T√≠nh r√µ r√†ng", clarity)}
${createScoreBox("T√≠nh ch√≠nh x√°c", accuracy)}
${createScoreBox("T√≠nh c·ª• th·ªÉ", precision)}
${createScoreBox("T√≠nh li√™n quan", relevance)}
${createScoreBox("ƒê·ªô s√¢u ph√¢n t√≠ch", depth)}
${createScoreBox("ƒê·ªô bao qu√°t", breadth)}
${createScoreBox("T√≠nh logic", logic)}
${createScoreBox("M·ª©c ƒë·ªô quan tr·ªçng", significance)}
${createScoreBox("T√≠nh c√¥ng b·∫±ng", fairness)}
      </div>

      <div class="summary-feedback" style="margin-top:30px;">
        <strong>∆Øu ƒëi·ªÉm:</strong><br>
        ${(debate.strengths || []).join("<br>") || "‚Äî"}

        <br><br>

        <strong>H·∫°n ch·∫ø:</strong><br>
        ${(debate.weaknesses || []).join("<br>") || "‚Äî"}
      </div>

    </div>
  `;
}

function createScoreBox(title, value){
  return `
    <div class="score-box glass">
      <div>${title}</div>
      <div class="score-value">${value}</div>
      <div class="score-desc">/10 ƒëi·ªÉm</div>
    </div>
  `;
}

function generateFinalMindmap(decision, mindmaps, rolesData = {}) {

const container = document.getElementById("finalMindmap");
container.innerHTML = "";

// ===== EXPORT BUTTON =====
const exportBtn = document.createElement("button");
exportBtn.className = "export-btn";
exportBtn.innerText = "‚¨á Xu·∫•t PNG";
exportBtn.onclick = (e) => exportMindmapImage(e);
container.appendChild(exportBtn);

// ===== VIEWPORT =====
const viewport = document.createElement("div");
viewport.className = "mindmap-viewport";
container.appendChild(viewport);

const width = 2000;
const height = 1400;

const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
svg.setAttribute("width", width);
svg.setAttribute("height", height);
svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
svg.classList.add("mindmap-svg");
viewport.appendChild(svg);

const rootX = width / 2;
const rootY = height / 2;

createNode(decision.finalDecision || "CH·ª¶ ƒê·ªÄ", rootX, rootY, 0);

const roles = Object.keys(mindmaps);

// ===== T√çNH MAX DEPTH =====
function getMaxDepth(children, depth = 1) {
  let max = depth;
  children.forEach(c => {
    if (c.children?.length) {
      max = Math.max(max, getMaxDepth(c.children, depth + 1));
    }
  });
  return max;
}

let maxDepth = 1;

roles.forEach(role => {
  const children = mindmaps[role]?.children || [];
  maxDepth = Math.max(maxDepth, getMaxDepth(children));
});

maxDepth = Math.min(maxDepth, 5);

// ===== HORIZONTAL SPACING TƒÇNG M·∫†NH =====
const horizontalSpacing = 350 + (maxDepth * 40);

const left = [];
const right = [];

roles.forEach((r, i) => {
  if (i % 2 === 0) right.push(r);
  else left.push(r);
});

renderSide(right, 1);
renderSide(left, -1);

// ===== RENDER SIDE =====
function renderSide(roleList, direction) {

  const spacingY = height / (roleList.length + 1);

  roleList.forEach((role, index) => {

    const roleY = spacingY * (index + 1);
    const roleX = rootX + (direction * horizontalSpacing);

    const clampedX = roleX;
    const roleLabel = rolesData[role]?.ten || role;

    createNode(roleLabel, clampedX, roleY, 1);
    drawLine(rootX, rootY, clampedX, roleY, 1);

    const children = mindmaps[role]?.children || [];

    renderChildren(children, clampedX, roleY, direction, 2);
  });
}

// ===== CHILDREN (GI·ªêNG SIMULATION) =====
function renderChildren(children, parentX, parentY, direction, level) {

  if (!children || level > 5) return;

  const tempNodes = children.map(child => {
    const temp = createNode(child.text, -9999, -9999, level);
    return { child, element: temp, height: temp.offsetHeight };
  });

  let totalNodesHeight =
    tempNodes.reduce((sum, n) => sum + n.height, 0);

  const availableSpace = height * 0.6;
  let verticalGap =
    (availableSpace - totalNodesHeight) / (children.length - 1);

  verticalGap = Math.max(30, Math.min(90, verticalGap));

  let totalHeight =
    totalNodesHeight + verticalGap * (children.length - 1);

  let currentY = parentY - totalHeight / 2;

  tempNodes.forEach(({ child, element, height }) => {

    const x = parentX + (direction * horizontalSpacing);
    const y = currentY + height / 2;

    const clampedX = x;

    element.style.left = clampedX + "px";
    element.style.top = y + "px";

    drawLine(parentX, parentY, clampedX, y, level);

    currentY += height + verticalGap;

    if (child.children?.length) {
      renderChildren(
        child.children,
        clampedX,
        y,
        direction,
        level + 1
      );
    }
  });
}

// ===== NODE =====
function createNode(text, x, y, level) {
  const node = document.createElement("div");
  node.className = "mindmap-node level-" + level;
  node.innerText = text;
  node.style.left = x + "px";
  node.style.top = y + "px";
  node.style.transform = "translate(-50%, -50%)";
  viewport.appendChild(node);
  return node;
}

function drawLine(x1, y1, x2, y2, level = 1) {

  const line = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "line"
  );

  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  if (!length) return;

  let shortenStart = 18;
  let shortenEnd = 22;

  if (length < 120) {
    shortenStart = 0;
    shortenEnd = 0;
  }

  const unitX = dx / length;
  const unitY = dy / length;

  line.setAttribute("x1", x1 + unitX * shortenStart);
  line.setAttribute("y1", y1 + unitY * shortenStart);
  line.setAttribute("x2", x2 - unitX * shortenEnd);
  line.setAttribute("y2", y2 - unitY * shortenEnd);

  line.classList.add("mindmap-line");

  const isLight = document.body.classList.contains("light-mode");
  const lineColor = isLight ? "#000" : "#ffffff";

  line.setAttribute("stroke", lineColor);
  line.setAttribute("stroke-width", "2");
  line.setAttribute("stroke-linecap", "round");
  line.setAttribute("vector-effect", "non-scaling-stroke");

  svg.appendChild(line);
}
// ===== ZOOM + DRAG PRO VERSION =====

let scale = 1;
let minScale = 0.2;   // üî• zoom nh·ªè h∆°n n·ªØa
let maxScale = 5;     // üî• zoom to h∆°n nhi·ªÅu

let isDragging = false;
let startX, startY;

let translateX = (container.clientWidth - width) / 2;
let translateY = (container.clientHeight - height) / 2;

updateTransform();

function updateTransform() {
  viewport.style.transform =
    `translate(${translateX}px, ${translateY}px) scale(${scale})`;
}

// ===== ZOOM THEO CON TR·ªé CHU·ªòT =====
container.addEventListener("wheel", (e) => {

  e.preventDefault();

  const rect = container.getBoundingClientRect();

  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const zoomFactor = 1.15; // üî• t·ªëc ƒë·ªô zoom

  const oldScale = scale;

  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }

  scale = Math.max(minScale, Math.min(maxScale, scale));

  // üî• Gi·ªØ ƒëi·ªÉm chu·ªôt c·ªë ƒë·ªãnh khi zoom
  translateX =
    mouseX - (mouseX - translateX) * (scale / oldScale);

  translateY =
    mouseY - (mouseY - translateY) * (scale / oldScale);

  updateTransform();
});

// ===== DRAG =====
container.addEventListener("mousedown", (e) => {
  isDragging = true;
  container.style.cursor = "grabbing";
  startX = e.clientX - translateX;
  startY = e.clientY - translateY;
});

window.addEventListener("mouseup", () => {
  isDragging = false;
  container.style.cursor = "grab";
});

container.addEventListener("mousemove", (e) => {
  if (!isDragging) return;
  translateX = e.clientX - startX;
  translateY = e.clientY - startY;
  updateTransform();
});

// ===== DOUBLE CLICK RESET =====
container.addEventListener("dblclick", () => {
  scale = 1;
  translateX = (container.clientWidth - width) / 2;
  translateY = (container.clientHeight - height) / 2;
  updateTransform();
});

async function exportMindmapImage(event) {

  event.stopPropagation();

  const viewport = document.querySelector(".mindmap-viewport");
  const container = document.getElementById("finalMindmap");

  const oldTransform = viewport.style.transform;

  // Reset zoom
  viewport.style.transform = "translate(0px,0px) scale(1)";

  // ===== B·∫¨T CH·∫æ ƒê·ªò EXPORT =====
  container.classList.add("exporting");

  try {

    const canvas = await html2canvas(viewport, {
      backgroundColor: "#ffffff",
      width: 2000,
      height: 1400,
      scale: 2,
      useCORS: true
    });

    const link = document.createElement("a");
    link.download = "critical-ai-history-mindmap.png";
    link.href = canvas.toDataURL("image/png");
    link.click();

  } catch (err) {
    alert("Kh√¥ng th·ªÉ xu·∫•t ·∫£nh.");
    console.error(err);
  }

  // ===== T·∫ÆT EXPORT MODE =====
  container.classList.remove("exporting");

  viewport.style.transform = oldTransform;
}
}

function goToCriteria() {
  window.location.href = "Introduction.html#criteria";
}

loadHistory();

</script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</body>
</html>